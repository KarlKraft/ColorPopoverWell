//
//  PaintCode.swift
//  ColorPopoverWell
//
//  Created by Karl Kraft on 2/1/14.
//  Copyright 2014-2022 Karl Kraft. Licensed under Apache License, Version 2.0
//

//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//

import Cocoa

internal class PaintCode: NSObject {
  //// Drawing Methods

  @objc public dynamic class func drawPopoverWell(frame targetFrame: NSRect = NSRect(x: 0, y: 0, width: 66, height: 23), resizing: ResizingBehavior = .stretch, accentColor: NSColor = NSColor(red: 0.895, green: 0.537, blue: 0.034, alpha: 1), color: NSColor = NSColor(red: 0.942, green: 0.959, blue: 0.248, alpha: 1), showDropIndicator: Bool = false, showColorHover: Bool = false, showColorTrack: Bool = false, showWheelHover: Bool = false, showWheelTrack: Bool = false, showWheelActive: Bool = false) {
    //// General Declarations
    let context = NSGraphicsContext.current!.cgContext

    //// Resize to Target Frame
    NSGraphicsContext.saveGraphicsState()
    let resizedFrame: NSRect = resizing.apply(rect: NSRect(x: 0, y: 0, width: 66, height: 23), target: targetFrame)
    context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
    context.scaleBy(x: resizedFrame.width / 66, y: resizedFrame.height / 23)

    let accentHSB = accentColor.usingColorSpace(.deviceRGB)!
    //// Color Declarations
    let accentColorDark = NSColor(hue: accentHSB.hueComponent, saturation: accentHSB.saturationComponent, brightness: 0.5, alpha: accentHSB.alphaComponent)
    let frameColor = NSColor(red: 0.573, green: 0.568, blue: 0.569, alpha: 1)
    let gradientColor = NSColor(red: 0, green: 0, blue: 0, alpha: 0.03)
    let gradientColor2 = NSColor(red: 0, green: 0, blue: 0, alpha: 0.495)

    //// Gradient Declarations
    let gradient = NSGradient(starting: gradientColor2, ending: gradientColor)!
    let gradient2 = NSGradient(starting: accentColor, ending: NSColor.white)!

    if showWheelTrack {
      //// WheelTrackIndicator Drawing
      let wheelTrackIndicatorCornerRadius: CGFloat = 3
      let wheelTrackIndicatorRect = NSRect(x: 46, y: 0.5, width: 19.5, height: 22)
      let wheelTrackIndicatorInnerRect = wheelTrackIndicatorRect.insetBy(dx: wheelTrackIndicatorCornerRadius, dy: wheelTrackIndicatorCornerRadius)
      let wheelTrackIndicatorPath = NSBezierPath()
      wheelTrackIndicatorPath.move(to: NSPoint(x: wheelTrackIndicatorRect.minX, y: wheelTrackIndicatorRect.minY))
      wheelTrackIndicatorPath.appendArc(withCenter: NSPoint(x: wheelTrackIndicatorInnerRect.maxX, y: wheelTrackIndicatorInnerRect.minY), radius: wheelTrackIndicatorCornerRadius, startAngle: 270, endAngle: 360)
      wheelTrackIndicatorPath.appendArc(withCenter: NSPoint(x: wheelTrackIndicatorInnerRect.maxX, y: wheelTrackIndicatorInnerRect.maxY), radius: wheelTrackIndicatorCornerRadius, startAngle: 0, endAngle: 90)
      wheelTrackIndicatorPath.line(to: NSPoint(x: wheelTrackIndicatorRect.minX, y: wheelTrackIndicatorRect.maxY))
      wheelTrackIndicatorPath.close()
      gradient2.draw(in: wheelTrackIndicatorPath, angle: -90)
    }

    if showWheelActive {
      //// WheelActiveIndicator Drawing
      let wheelActiveIndicatorCornerRadius: CGFloat = 3
      let wheelActiveIndicatorRect = NSRect(x: 46, y: 0.5, width: 19.5, height: 22)
      let wheelActiveIndicatorInnerRect = wheelActiveIndicatorRect.insetBy(dx: wheelActiveIndicatorCornerRadius, dy: wheelActiveIndicatorCornerRadius)
      let wheelActiveIndicatorPath = NSBezierPath()
      wheelActiveIndicatorPath.move(to: NSPoint(x: wheelActiveIndicatorRect.minX, y: wheelActiveIndicatorRect.minY))
      wheelActiveIndicatorPath.appendArc(withCenter: NSPoint(x: wheelActiveIndicatorInnerRect.maxX, y: wheelActiveIndicatorInnerRect.minY), radius: wheelActiveIndicatorCornerRadius, startAngle: 270, endAngle: 360)
      wheelActiveIndicatorPath.appendArc(withCenter: NSPoint(x: wheelActiveIndicatorInnerRect.maxX, y: wheelActiveIndicatorInnerRect.maxY), radius: wheelActiveIndicatorCornerRadius, startAngle: 0, endAngle: 90)
      wheelActiveIndicatorPath.line(to: NSPoint(x: wheelActiveIndicatorRect.minX, y: wheelActiveIndicatorRect.maxY))
      wheelActiveIndicatorPath.close()
      accentColor.setFill()
      wheelActiveIndicatorPath.fill()
    }

    if showWheelHover {
      //// WheelHoverIndicator Drawing
      let wheelHoverIndicatorCornerRadius: CGFloat = 3
      let wheelHoverIndicatorRect = NSRect(x: 46, y: 0.5, width: 19.5, height: 22)
      let wheelHoverIndicatorInnerRect = wheelHoverIndicatorRect.insetBy(dx: wheelHoverIndicatorCornerRadius, dy: wheelHoverIndicatorCornerRadius)
      let wheelHoverIndicatorPath = NSBezierPath()
      wheelHoverIndicatorPath.move(to: NSPoint(x: wheelHoverIndicatorRect.minX, y: wheelHoverIndicatorRect.minY))
      wheelHoverIndicatorPath.appendArc(withCenter: NSPoint(x: wheelHoverIndicatorInnerRect.maxX, y: wheelHoverIndicatorInnerRect.minY), radius: wheelHoverIndicatorCornerRadius, startAngle: 270, endAngle: 360)
      wheelHoverIndicatorPath.appendArc(withCenter: NSPoint(x: wheelHoverIndicatorInnerRect.maxX, y: wheelHoverIndicatorInnerRect.maxY), radius: wheelHoverIndicatorCornerRadius, startAngle: 0, endAngle: 90)
      wheelHoverIndicatorPath.line(to: NSPoint(x: wheelHoverIndicatorRect.minX, y: wheelHoverIndicatorRect.maxY))
      wheelHoverIndicatorPath.close()
      gradient.draw(in: wheelHoverIndicatorPath, angle: -90)
    }

    //// ColorSwatch Drawing
    let colorSwatchCornerRadius: CGFloat = 3
    let colorSwatchRect = NSRect(x: 0.5, y: 0.5, width: 45.5, height: 22)
    let colorSwatchInnerRect = colorSwatchRect.insetBy(dx: colorSwatchCornerRadius, dy: colorSwatchCornerRadius)
    let colorSwatchPath = NSBezierPath()
    colorSwatchPath.appendArc(withCenter: NSPoint(x: colorSwatchInnerRect.minX, y: colorSwatchInnerRect.minY), radius: colorSwatchCornerRadius, startAngle: 180, endAngle: 270)
    colorSwatchPath.line(to: NSPoint(x: colorSwatchRect.maxX, y: colorSwatchRect.minY))
    colorSwatchPath.line(to: NSPoint(x: colorSwatchRect.maxX, y: colorSwatchRect.maxY))
    colorSwatchPath.appendArc(withCenter: NSPoint(x: colorSwatchInnerRect.minX, y: colorSwatchInnerRect.maxY), radius: colorSwatchCornerRadius, startAngle: 90, endAngle: 180)
    colorSwatchPath.close()
    color.setFill()
    colorSwatchPath.fill()

    if showColorHover {
      //// ColorHoverIndicator Drawing
      NSGraphicsContext.saveGraphicsState()
      context.setAlpha(0.8)

      let colorHoverIndicatorPath = NSBezierPath()
      colorHoverIndicatorPath.move(to: NSPoint(x: 35, y: 6))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 41, y: 12), controlPoint1: NSPoint(x: 38.28, y: 6), controlPoint2: NSPoint(x: 41, y: 8.72))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 34.99, y: 18), controlPoint1: NSPoint(x: 41, y: 15.28), controlPoint2: NSPoint(x: 38.27, y: 18))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 29, y: 12), controlPoint1: NSPoint(x: 31.71, y: 18), controlPoint2: NSPoint(x: 29, y: 15.28))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 35, y: 6), controlPoint1: NSPoint(x: 29, y: 8.72), controlPoint2: NSPoint(x: 31.72, y: 6))
      colorHoverIndicatorPath.close()
      colorHoverIndicatorPath.move(to: NSPoint(x: 34.68, y: 9.72))
      colorHoverIndicatorPath.line(to: NSPoint(x: 32.62, y: 13.19))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 32.86, y: 13.77), controlPoint1: NSPoint(x: 32.47, y: 13.44), controlPoint2: NSPoint(x: 32.59, y: 13.77))
      colorHoverIndicatorPath.line(to: NSPoint(x: 37.12, y: 13.77))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 37.37, y: 13.19), controlPoint1: NSPoint(x: 37.4, y: 13.77), controlPoint2: NSPoint(x: 37.52, y: 13.46))
      colorHoverIndicatorPath.line(to: NSPoint(x: 35.31, y: 9.72))
      colorHoverIndicatorPath.curve(to: NSPoint(x: 34.68, y: 9.72), controlPoint1: NSPoint(x: 35.17, y: 9.47), controlPoint2: NSPoint(x: 34.83, y: 9.48))
      colorHoverIndicatorPath.close()
      NSColor.gray.setFill()
      colorHoverIndicatorPath.fill()

      NSGraphicsContext.restoreGraphicsState()
    }

    if showColorTrack {
      //// ColorClickIndicator Drawing
      let colorClickIndicatorCornerRadius: CGFloat = 3
      let colorClickIndicatorRect = NSRect(x: 0.5, y: 0.5, width: 45.5, height: 22)
      let colorClickIndicatorInnerRect = colorClickIndicatorRect.insetBy(dx: colorClickIndicatorCornerRadius, dy: colorClickIndicatorCornerRadius)
      let colorClickIndicatorPath = NSBezierPath()
      colorClickIndicatorPath.appendArc(withCenter: NSPoint(x: colorClickIndicatorInnerRect.minX, y: colorClickIndicatorInnerRect.minY), radius: colorClickIndicatorCornerRadius, startAngle: 180, endAngle: 270)
      colorClickIndicatorPath.line(to: NSPoint(x: colorClickIndicatorRect.maxX, y: colorClickIndicatorRect.minY))
      colorClickIndicatorPath.line(to: NSPoint(x: colorClickIndicatorRect.maxX, y: colorClickIndicatorRect.maxY))
      colorClickIndicatorPath.appendArc(withCenter: NSPoint(x: colorClickIndicatorInnerRect.minX, y: colorClickIndicatorInnerRect.maxY), radius: colorClickIndicatorCornerRadius, startAngle: 90, endAngle: 180)
      colorClickIndicatorPath.close()
      gradient.draw(in: colorClickIndicatorPath, angle: -90)
    }

    //// Frame
    //// RoundedFrame Drawing
    let roundedFramePath = NSBezierPath(roundedRect: NSRect(x: 0.5, y: 0.5, width: 65, height: 22), xRadius: 3, yRadius: 3)
    frameColor.setStroke()
    roundedFramePath.lineWidth = 1
    roundedFramePath.stroke()

    //// VerticalLine Drawing
    let verticalLinePath = NSBezierPath()
    verticalLinePath.move(to: NSPoint(x: 45.5, y: 22.5))
    verticalLinePath.line(to: NSPoint(x: 45.5, y: 0.5))
    frameColor.setStroke()
    verticalLinePath.lineWidth = 1
    verticalLinePath.stroke()

    if showDropIndicator {
      //// ColorDropIndicator Drawing
      let colorDropIndicatorPath = NSBezierPath()
      colorDropIndicatorPath.move(to: NSPoint(x: 44, y: 20.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 5.56, y: 20.5))
      colorDropIndicatorPath.curve(to: NSPoint(x: 5.37, y: 20.5), controlPoint1: NSPoint(x: 5.49, y: 20.5), controlPoint2: NSPoint(x: 5.43, y: 20.5))
      colorDropIndicatorPath.curve(to: NSPoint(x: 3.76, y: 20.35), controlPoint1: NSPoint(x: 4.61, y: 20.5), controlPoint2: NSPoint(x: 4.2, y: 20.49))
      colorDropIndicatorPath.curve(to: NSPoint(x: 2.65, y: 19.24), controlPoint1: NSPoint(x: 3.25, y: 20.16), controlPoint2: NSPoint(x: 2.84, y: 19.75))
      colorDropIndicatorPath.curve(to: NSPoint(x: 2.5, y: 17.44), controlPoint1: NSPoint(x: 2.5, y: 18.76), controlPoint2: NSPoint(x: 2.5, y: 18.32))
      colorDropIndicatorPath.line(to: NSPoint(x: 2.5, y: 5.56))
      colorDropIndicatorPath.curve(to: NSPoint(x: 2.65, y: 3.76), controlPoint1: NSPoint(x: 2.5, y: 4.68), controlPoint2: NSPoint(x: 2.5, y: 4.24))
      colorDropIndicatorPath.curve(to: NSPoint(x: 3.76, y: 2.65), controlPoint1: NSPoint(x: 2.84, y: 3.25), controlPoint2: NSPoint(x: 3.25, y: 2.84))
      colorDropIndicatorPath.curve(to: NSPoint(x: 5.56, y: 2.5), controlPoint1: NSPoint(x: 4.24, y: 2.5), controlPoint2: NSPoint(x: 4.68, y: 2.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 44, y: 2.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 44, y: 20.5))
      colorDropIndicatorPath.close()
      colorDropIndicatorPath.move(to: NSPoint(x: 46, y: 22.5))
      colorDropIndicatorPath.curve(to: NSPoint(x: 46, y: 0.5), controlPoint1: NSPoint(x: 46, y: 22.5), controlPoint2: NSPoint(x: 46, y: 0.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 5.09, y: 0.5))
      colorDropIndicatorPath.curve(to: NSPoint(x: 2.51, y: 0.7), controlPoint1: NSPoint(x: 3.77, y: 0.5), controlPoint2: NSPoint(x: 3.11, y: 0.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 2.39, y: 0.72))
      colorDropIndicatorPath.curve(to: NSPoint(x: 0.72, y: 2.39), controlPoint1: NSPoint(x: 1.62, y: 1.01), controlPoint2: NSPoint(x: 1.01, y: 1.62))
      colorDropIndicatorPath.curve(to: NSPoint(x: 0.5, y: 5.09), controlPoint1: NSPoint(x: 0.5, y: 3.11), controlPoint2: NSPoint(x: 0.5, y: 3.77))
      colorDropIndicatorPath.line(to: NSPoint(x: 0.5, y: 17.91))
      colorDropIndicatorPath.curve(to: NSPoint(x: 0.7, y: 20.49), controlPoint1: NSPoint(x: 0.5, y: 19.23), controlPoint2: NSPoint(x: 0.5, y: 19.89))
      colorDropIndicatorPath.line(to: NSPoint(x: 0.72, y: 20.61))
      colorDropIndicatorPath.curve(to: NSPoint(x: 1.93, y: 22.06), controlPoint1: NSPoint(x: 0.95, y: 21.22), controlPoint2: NSPoint(x: 1.38, y: 21.73))
      colorDropIndicatorPath.curve(to: NSPoint(x: 2.39, y: 22.28), controlPoint1: NSPoint(x: 2.08, y: 22.14), controlPoint2: NSPoint(x: 2.23, y: 22.22))
      colorDropIndicatorPath.curve(to: NSPoint(x: 5.09, y: 22.5), controlPoint1: NSPoint(x: 3.11, y: 22.5), controlPoint2: NSPoint(x: 3.77, y: 22.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 46, y: 22.5))
      colorDropIndicatorPath.line(to: NSPoint(x: 46, y: 22.5))
      colorDropIndicatorPath.close()
      accentColor.setFill()
      colorDropIndicatorPath.fill()
      accentColorDark.setStroke()
      colorDropIndicatorPath.lineWidth = 1
      colorDropIndicatorPath.stroke()
    }

    //// ColorWheel

    NSImage(named: "NSColorPanel")?.draw(in: NSRect(x: 47.5, y: 4, width: 16, height: 16), from: NSZeroRect, operation: .sourceOver, fraction: 1.0)

    NSGraphicsContext.restoreGraphicsState()
  }

  @objc(PaintCodeResizingBehavior)
  public enum ResizingBehavior: Int {
    case aspectFit /// The content is proportionally resized to fit into the target rectangle.
    case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
    case stretch /// The content is stretched to match the entire target rectangle.
    case center /// The content is centered in the target rectangle, but it is NOT resized.

    public func apply(rect: NSRect, target: NSRect) -> NSRect {
      if rect == target || target == NSRect.zero {
        return rect
      }

      var scales = NSSize.zero
      scales.width = abs(target.width / rect.width)
      scales.height = abs(target.height / rect.height)

      switch self {
      case .aspectFit:
        scales.width = min(scales.width, scales.height)
        scales.height = scales.width
      case .aspectFill:
        scales.width = max(scales.width, scales.height)
        scales.height = scales.width
      case .stretch:
        break
      case .center:
        scales.width = 1
        scales.height = 1
      }

      var result = rect.standardized
      result.size.width *= scales.width
      result.size.height *= scales.height
      result.origin.x = target.minX + (target.width - result.width) / 2
      result.origin.y = target.minY + (target.height - result.height) / 2
      return result
    }
  }
}
